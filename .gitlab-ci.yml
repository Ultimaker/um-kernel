# yamllint disable rule:line-length
# SPDX-License-Identifier: AGPL-3.0+
#
# Copyright (C) 2019 Ultimaker B.V.
#
# GitLab CI package build is split up into two parts.
# * Build environment: creates the docker image that is needed for package generation
# * Package generation: creates the final artifact

---
stages:
  - lint
  - prepare
  - push
  - build
  # - test
  - cleanup

# Common requisites
# ==========
.parameters_common: &parameters_common
  tags:
    - docker

.changes_docker: &changes_docker
  changes:
    - Dockerfile
    - .dockerignore
    - dockerfiles/**/*

.shell_linting_common: &shell_linting_common
  <<: *parameters_common
  image: registry.hub.docker.com/koalaman/shellcheck-alpine:stable
  stage: lint

lint_build_scripts:
  <<: *shell_linting_common
  script:
    - shellcheck -C -f tty "build"*".sh"

lint_test_scripts:
  <<: *shell_linting_common
  script:
    - find 'test/' -iname '*.sh' -exec shellcheck -x -C -f tty {} \;

# Environment (Docker)
# ====================
.build_environment_common: &build_environment_common
  <<: *parameters_common
  image: registry.hub.docker.com/library/docker:stable
  before_script:
    - |
      apk update && apk add git

prepare_build_environment:
  <<: *build_environment_common
  stage: prepare
  script:
    - |
      if git whatchanged --name-only --pretty="" master...HEAD | grep "Dockerfile\|.dockerignore"; then
        echo "Dockerfile changes detected..."
        docker build --rm -t "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}" .
        docker run \
        --rm \
        "$CI_COMMIT_SHA:$CI_PIPELINE_ID" \
        /test/buildenv_check.sh
      else
        echo "No Dockerfile changes..."
        docker login -u gitlab-ci-token -p "${CI_JOB_TOKEN}" "${CI_REGISTRY}"
        docker tag "${CI_REGISTRY_IMAGE}:latest" "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
        docker push "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
      fi

# The push to the Docker registry is thus only executed when docker changes are
# performed and the working branch is 'master'
push_build_environment:
  <<: *build_environment_common
  only:
    <<: *changes_docker
    refs:
      - master
  stage: push
  script:
    - |
      docker login -u gitlab-ci-token -p "${CI_JOB_TOKEN}" "${CI_REGISTRY}"
      docker tag  "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}" "${CI_REGISTRY_IMAGE}:latest"
      docker push "${CI_REGISTRY_IMAGE}:latest"

cleanup_build_environment:
  <<: *build_environment_common
  stage: cleanup
  except:
    refs:
      - master
  when: always
  script:
    - |
      if git whatchanged --name-only --pretty="" master...HEAD | grep "Dockerfile\|.dockerignore"; then
        if docker inspect --type image "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}" 1> /dev/null; then
          docker rmi "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
        fi
      fi

# Package generation
# ==================
.build_pkg_common: &build_pkg_common
  <<: *parameters_common
  stage: build
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
  script:
    - ./build.sh
  artifacts:
    name: "$CI_COMMIT_REF_NAME-$CI_COMMIT_SHA"
    paths:
      - ./*.deb
    expire_in: 3 days

.docker_branch: &docker_branch
  except:
    refs:
      - master
  image: "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"

.docker_master: &docker_master
  only:
    refs:
      - master
  image: "${CI_REGISTRY_IMAGE}:latest"

  # Build the package on a non-master branch in a modified Docker image.
build:branch:
  <<: *build_pkg_common
  <<: *docker_branch

# Build the package on the master branch in the latest Docker image.
build:master:
  <<: *build_pkg_common
  <<: *docker_master
